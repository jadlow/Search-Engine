/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.luence.app;

import org.apache.lucene.analysis.en.EnglishAnalyzer;
import org.apache.lucene.analysis.standard.StandardAnalyzer;
import org.apache.lucene.document.Document;
import org.apache.lucene.index.*;
import org.apache.lucene.queryparser.classic.MultiFieldQueryParser;
import org.apache.lucene.queryparser.classic.ParseException;
import org.apache.lucene.queryparser.classic.QueryParser;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.ScoreDoc;
import org.apache.lucene.search.TopDocs;
import org.apache.lucene.search.similarities.BM25Similarity;
import org.apache.lucene.search.similarities.BooleanSimilarity;
import org.apache.lucene.search.similarities.ClassicSimilarity;
import org.apache.lucene.store.Directory;
import org.apache.lucene.store.NIOFSDirectory;

import java.io.IOException;
import java.io.File;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;

public class Search {
    private static List<String> stopwords;
    public static String removeStopwords(String input, HashSet<String> stopwords) {
        String[] words = input.split("\\s+");

        StringBuilder resultBuilder = new StringBuilder();

        for (String word : words) {
            if (!stopwords.contains(word.toLowerCase())) {
                resultBuilder.append(word).append(" ");
            }
        }

        // Convert the StringBuilder to a string and trim trailing spaces
        String result = resultBuilder.toString().trim();

        return result;
    }

    public static String PRF(String original_query, IndexSearcher searcher, IndexReader reader) throws IOException, ParseException{
        String new_query = original_query;
        int numPRF= 5;

        StandardAnalyzer analyzer = new StandardAnalyzer();
        QueryParser parser2 = new QueryParser("ab", analyzer);

        Query parsed_query = parser2.parse(QueryParser.escape(original_query));
        HashMap<String, Integer> topKFreq = new HashMap<>();

        TopDocs docs = searcher.search(parsed_query, numPRF);
        ScoreDoc[] hits = docs.scoreDocs;
        for (int i = 0; i < hits.length; ++i) {
            String[] terms = parsed_query.toString().split("ab:");
            for (String term: terms){
                if(topKFreq.containsKey(term))
                {
                    topKFreq.put(term, topKFreq.get(term)+1);
                }
                else
                {
                    topKFreq.put(term, 1);
                }
            }
        }
        HashMap<String, Float> kl_scores = new HashMap<>();
        long collectionNumTerms = reader.getSumTotalTermFreq("ab");
        Collection<String> keys = topKFreq.keySet();
        Collection<Integer> values = topKFreq.values();
        Integer[] arr = values.toArray(new Integer[0]);
        String[] keySet = keys.toArray(new String[0]);
        for (int i = 0; i < topKFreq.size(); i++){
            // # of times in top k docs / number of terms in top k docs
            float p = (float)arr[i]/(float)topKFreq.size();
            long termFreq = reader.totalTermFreq(new Term("ab", keySet[i].trim()));
            // total # of times in collection / total number off terms in collection
            float q = (float) termFreq/(float)collectionNumTerms;
            float kl_score = p * (float) Math.log(p/q);
            kl_scores.put(keySet[i].trim(), kl_score);
        }

        LinkedHashMap<String, Float> sorted_kl_scores = new LinkedHashMap<>();

        kl_scores.entrySet()
                .stream()
                .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))
                .limit(5)
                .forEachOrdered(x -> sorted_kl_scores.put(x.getKey(), x.getValue()));

        for (String key : sorted_kl_scores.keySet()){
            new_query = new_query + " " + key;
        }
        return new_query;
    }
    public static void main(String[] args) throws IOException, ParseException {
        // "Boolean" or "TF" or "TFIDF" or "PRF" or "Custom"
        String rankingAlgorithm = "Custom";
        int hitsPerPage = 50;

        // Define the set of stopwords manually
        HashSet<String> stopwords = new HashSet<>(Arrays.asList(
                "a", "an", "and", "are", "as", "at", "be", "by", "for", "from",
                "has", "in", "is", "it", "its", "of", "on", "that", "the",
                "to", "was", "were", "will", "with", "he", "him", "his", "himself",
                "she", "her", "hers", "herself", "they", "them", "themselves", "theirs",
                "my", ",", ";", "*", "/"
        ));

        Directory index = null;

        if (rankingAlgorithm == "Custom"){
            index = NIOFSDirectory.open(Paths.get("C:\\Users\\jacob\\Desktop\\CSE272\\CSE272_UCSC_Spring\\HW1\\java\\customIndex"));
        }else{
            index = NIOFSDirectory.open(Paths.get("C:\\Users\\jacob\\Desktop\\CSE272\\CSE272_UCSC_Spring\\HW1\\java\\baselineIndex"));
        }
        IndexReader reader = DirectoryReader.open(index);
        IndexSearcher searcher = new IndexSearcher(reader);
        PrintWriter writer = new PrintWriter("C:\\Users\\jacob\\Desktop\\CSE272\\CSE272_UCSC_Spring\\HW1\\java\\results\\" + rankingAlgorithm + ".txt");

        switch (rankingAlgorithm) {
            case "Boolean":
                searcher.setSimilarity(new BooleanSimilarity());
                break;
            case "TF":
                searcher.setSimilarity(new CustomTFSimilarity());
                break;
            case "TFIDF":
                searcher.setSimilarity(new ClassicSimilarity());
                break;
            case "PRF":
                searcher.setSimilarity(new ClassicSimilarity());
            case "Custom":
                searcher.setSimilarity(new ClassicSimilarity());
            default:
                searcher.setSimilarity(new BM25Similarity());
                break;
        }

        String query_doc = Files.readString(new File("C:\\Users\\jacob\\Desktop\\CSE272\\CSE272_UCSC_Spring\\HW1\\java\\query.ohsu.1-63").toPath(), StandardCharsets.UTF_8);

        MultiFieldQueryParser parser = null;

        long startTime = System.currentTimeMillis();
        String[] queries = query_doc.split("</top>");
        for (String query : queries){
            if (query.trim().length() == 0){
                break;
            }
            String[] parts = query.split("<num>|<title>|<desc>");
            String number = parts[1].substring(8).trim();
            String title = parts[2].trim().trim();
            String description = parts[3].substring(13).trim();
            String query_string = title + " " + description;

//            query_string = removeStopwords(query_string, stopwords);
            if (rankingAlgorithm == "Custom"){
                // porter stemmer and english possessive
                EnglishAnalyzer analyzer = new EnglishAnalyzer();
                // boost different fields
                Map<String, Float> boosts = new HashMap<>();
                boosts.put("title", 1f);
                boosts.put("ab", 1f);
                boosts.put("mesh", 1f);
                parser = new MultiFieldQueryParser(new String[]{"title", "ab", "mesh"}, analyzer, boosts);
                // remove stopwords from query
                query_string = removeStopwords(query_string, stopwords);
            }else{
                // baseline analyzer and parser without boosting
                StandardAnalyzer analyzer = new StandardAnalyzer();
                parser = new MultiFieldQueryParser(new String[]{"title", "ab", "mesh"}, analyzer);
            }
            // pseudo relevance feedback query expansion
            if (rankingAlgorithm == "PRF"){
                query_string = PRF(query_string, searcher, reader);
            }

            // get query for entire title and description
            // QueryParser.escape fixed bug with "\" character
            Query parsed_query = parser.parse(QueryParser.escape(query_string));
            TopDocs docs = searcher.search(parsed_query, hitsPerPage);
            ScoreDoc[] hits = docs.scoreDocs;

//            System.out.println("Found " + hits.length + " hits.");
            for (int i = 0; i < hits.length; ++i) {
                int docId = hits[i].doc;
                Document d = searcher.doc(docId);
//                System.out.println(number + " Q0 " + d.get("med_id") + " " + (i+1) + " " + hits[i].score + " Boolean");
                writer.println(number + "   Q0    " + d.get("med_id") + "   " + (i+1) + "   " + hits[i].score + "   " + rankingAlgorithm);
            }
        }
        long endTime = System.currentTimeMillis();
        System.out.println("Time:" + (endTime - startTime) + "ms");
        writer.close();
    }
}
